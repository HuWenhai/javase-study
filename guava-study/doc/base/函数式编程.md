http://ifeve.com/google-guava-functional/

Guava提供两个基本的函数式接口：

Function<A, B>，它声明了单个方法B apply(A input)。Function对象通常被预期为引用透明的——没有副作用——并且引用透明性中的”相等”语义与equals一致，如a.equals(b)意味着function.apply(a).equals(function.apply(b))。

Predicate<T>，它声明了单个方法boolean apply(T input)。Predicate对象通常也被预期为无副作用函数，并且”相等”语义与equals一致。

请务必确保，当使用Guava函数式的时候，用传统的命令式做同样的事情不会更具可读性。尝试把代码写下来，看看它是不是真的那么糟糕？会不会比你想尝试的极其笨拙的函数式 更具可读性。

*函数式*

<pre>
Function<String, Integer> lengthFunction = new Function<String, Integer>() {
    @Override
    public Integer apply(String s) {
        return s.length();
    }
};
System.out.println(lengthFunction.apply("Edgar"));

Predicate<String> allCaps = new Predicate<String>() {
    @Override
    public boolean apply(String input) {
        return CharMatcher.JAVA_UPPER_CASE.matchesAllOf(input);
    }
};
System.out.println(allCaps.apply("JAVA"));

List<String> strings = new ArrayList<String>();
strings.add("JAVA");
strings.add("Java");
strings.add("Edgar");
strings.add("EDGAR");
Multiset<Integer> lengths = HashMultiset.create(Iterables.transform(Iterables.filter(strings, allCaps), lengthFunction));
System.out.println(lengths);
</pre>

*命令式*

<pre>
List<String> strings = new ArrayList<String>();
strings.add("JAVA");
strings.add("Java");
strings.add("Edgar");
strings.add("EDGAR");
Multiset<Integer> lengths = HashMultiset.create();
for (String input : strings) {
    if (CharMatcher.JAVA_UPPER_CASE.matchesAllOf(input)) {
        lengths.add(input.length());
    }
}
</pre>

### Functions
#### forMap
Returns a function which performs a map lookup

<pre>
Map<String, String> map = new HashMap<String, String>();
map.put("username", "Edgar");
map.put("password", "test");
map.put("sex", "male");
String value = Functions.forMap(map).apply("username");
System.out.println(value);
value = Functions.forMap(map, "default").apply("email");
System.out.println(value);
value = Functions.forMap(map).apply("email");
//throw java.lang.IllegalArgumentException
</pre>