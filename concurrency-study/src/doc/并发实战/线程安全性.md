要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。

对象的状态是指存储在状态变量（例如实例或静态域）中的数据。对象的状态可能包括其他依赖对象的域

“共享”意味着变量可以由多个线程同时访问，“可变”意味着变量的值在其生命周期内可以发生变化。

当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。

在编写并发应用程序时，一种正确的编程方法就是:首先使代码正确运行，如何再提高代码的速度。

线程安全类中也可以包含非线程安全的类。在任何情况下，只有当类中仅包含自己的状态时，线程安全类才是有意义的。

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

**无状态的对象一定是线程安全的**

<pre>
@ThreadSafe
public class StatelessFactorizer extends HttpServlet {
	@Override
    public void service(ServletRequest request, ServletResponse response)
			throws ServletException, IOException {
		BigInteger i = extractFromRequest(request);
		BigInteger[] factors = factor(i);
		encodeIntoResponse(response, factors);
	}
}
</pre>

StatelessFactorizer是无状态的：它不包含域也没有引用其他类的域。
**一次特定计算的瞬时状态，会唯一地存在本地变量中，这些本地变量存储在线程的栈中，只有执行的线程才能访问。**
一个访问StatelessFactorizer的线程，不会影响访问同一个Servlet的其他线程的计算结果，因为两个线程不共享状态，它们如同在访问不同的实例

<pre>
@NotThreadSafe
public class UnsafeCountingFactorizer extends HttpServlet {

	private long count = 0;

	public long getCount() {
        return count;
	}

	@Override
	public void service(ServletRequest request, ServletResponse response)
			throws ServletException, IOException {
		BigInteger i = extractFromRequest(request);
		BigInteger[] factors = factor(i);
		++count;
		encodeIntoResponse(response, factors);
	}
}
</pre>
++count不是原子操作:获得当前值，加1，写回新值，这样会导致遗失更新。

### 静态条件
当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。
多个线程同时更新共享资源会引发竞态条件。
最常见的竞态条件就是“先检查后执行(Check-Then-Act)”操作，即通过一个可能失效的观测结果来决定下一步的动作。

导致竞态条件发生的代码区称作**临界区**。

